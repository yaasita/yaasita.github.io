<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>program on # cd ~yaasita</title>
    <link>https://yaasita.github.io/categories/program/</link>
    <description>Recent content in program on # cd ~yaasita</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 02 Aug 2023 01:45:09 +0900</lastBuildDate><atom:link href="https://yaasita.github.io/categories/program/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>perlでglobを使うときの注意</title>
      <link>https://yaasita.github.io/2023/08/02/perl-glob/</link>
      <pubDate>Wed, 02 Aug 2023 01:45:09 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2023/08/02/perl-glob/</guid>
      <description>スカラーコンテキストで評価する場合は注意
こんな感じでやると
#!/usr/bin/perl use strict; use warnings; use feature qw(:5.10); use utf8; testglob(); testglob(); sub testglob { my $path = glob(&amp;quot;~/hoge.txt&amp;quot;); say &amp;quot;file = $path&amp;quot;; } 結果はこうなる
file = /home/yamasita/hoge.txt Use of uninitialized value $path in concatenation (.) or string at test.pl line 12. file = 2回目はundefが返ってる
これはイテレーターになってるので、配列1個と、打ち止めのundefが返ってるから
というわけで、こういうときは配列で受け取ってイテレータを最後まで進めたほうが良い
my $path = @{[glob(&amp;quot;~/hoge.txt&amp;quot;)]}[0]; </description>
    </item>
    
    <item>
      <title>tumblrのoauth2</title>
      <link>https://yaasita.github.io/2023/08/01/tumblr-oauth-api/</link>
      <pubDate>Tue, 01 Aug 2023 01:22:00 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2023/08/01/tumblr-oauth-api/</guid>
      <description>これの通り
https://www.tumblr.com/docs/en/api/v2#oauth2-authorization
とりあえずAPI叩くまで解説
アプリの登録を以下のURLから行う
https://www.tumblr.com/oauth/register
次にパラメータを組み立てて認可リクエスト
scopeにoffline_accessがあるとrefresh_tokenがもらえて永続的に使えるけど、無い場合は認可リクエストからやり直す一時的なアクセストークンしかもらえない
let params = new URLSearchParams(); params.append(&#39;client_id&#39;, &#39;xxxxxxxxxxxxxxxxxxxxx&#39;); params.append(&#39;response_type&#39;, &#39;code&#39;); params.append(&#39;scope&#39;, &#39;basic offline_access&#39;); params.append(&#39;state&#39;, &#39;hogehoge1&#39;); let urlParams = params.toString(); console.log(`https://www.tumblr.com/oauth2/authorize?${urlParams}`) あとはリダイレクトURLにコードとstate付きで返ってくるので
https://example.com/?code=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;amp;state=hogehoge1#_=_ それみてアクセストークンと交換
コードの有効期限は結構短いので急ぐこと
curl -F grant_type=authorization_code -F code=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \ -F client_id=xxxxxxxxxxxxxxxxxxxxxxxxx \ -F client_secret=xxxxxxxxxxxxxxx https://api.tumblr.com/v2/oauth2/token リフレッシュトークンからアクセストークンを取得
ちなみにアクセストークンは40分くらいで有効期限が切れる
curl -F grant_type=refresh_token -F refresh_token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \ -F client_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \ -F client_secret=xxxxxxxxxxxxxxxxxxxxxxxxxxx https://api.tumblr.com/v2/oauth2/token あと注意なんだけど、refresh_tokenは使ったら、上記APIから新しいrefresh_tokenが来るので次回はそれを使うこと
（一度使ったrefresh_tokenはもう使えなくなる)</description>
    </item>
    
    <item>
      <title>5chのスレをパースする</title>
      <link>https://yaasita.github.io/2023/07/22/5ch-parse/</link>
      <pubDate>Sat, 22 Jul 2023 02:29:04 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2023/07/22/5ch-parse/</guid>
      <description>utf8にしたhtmlファイルを渡す</description>
    </item>
    
    <item>
      <title>ESMではNODEPATH使わない</title>
      <link>https://yaasita.github.io/2023/01/01/nodepath/</link>
      <pubDate>Sun, 01 Jan 2023 23:21:03 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2023/01/01/nodepath/</guid>
      <description>node.jsでNODE_PATHはESMで使えないみたいです
https://github.com/nodejs/node/issues/38687</description>
    </item>
    
    <item>
      <title>fargateでメタデータ取得</title>
      <link>https://yaasita.github.io/2022/11/20/get-metadata/</link>
      <pubDate>Sun, 20 Nov 2022 01:45:42 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2022/11/20/get-metadata/</guid>
      <description>ECS内からメタデータ叩いて、自分と同じタスク定義のコンテナが何個あるか数える
何に使うか分からんけど一応おいておく</description>
    </item>
    
    <item>
      <title>webページの存在証明</title>
      <link>https://yaasita.github.io/2022/10/02/exists/</link>
      <pubDate>Sun, 02 Oct 2022 22:06:36 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2022/10/02/exists/</guid>
      <description>このgpg鍵でwebページをpdfにしたやつに署名するという
まったく意味のないサービスを作った
https://exists.cloud.yaasita.net/</description>
    </item>
    
    <item>
      <title>apacheのautoindex経由で画像のスライドショー</title>
      <link>https://yaasita.github.io/2022/09/15/slideshow/</link>
      <pubDate>Thu, 15 Sep 2022 03:58:50 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2022/09/15/slideshow/</guid>
      <description>apacheのmod_autoindexが有効な状態でスライドショーを作る
こんな状態のディレクトリに
こんな感じのHTMLを置いて
スライドショー的に見る</description>
    </item>
    
    <item>
      <title>Power Automateのtips</title>
      <link>https://yaasita.github.io/2022/05/09/power-automate-tips/</link>
      <pubDate>Mon, 09 May 2022 03:24:42 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2022/05/09/power-automate-tips/</guid>
      <description>Desktop向けのPower Automateのちょっとしたことメモ
Dosコマンドでchromeを立ち上げる 操作する対象じゃなくて、そのままchromeをキックすればいい場合の設定方法
chorme.exeまでをフルパスでダブルクォートで囲む方法は上手くいかなかった
曜日取得 powershellでコマンド実行して
末尾に改行が入ってしまうので取り除く</description>
    </item>
    
    <item>
      <title>SMTP-TLSRPTのチェック</title>
      <link>https://yaasita.github.io/2022/02/12/tls-report-check/</link>
      <pubDate>Sat, 12 Feb 2022 01:24:48 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2022/02/12/tls-report-check/</guid>
      <description>SMTP-TLSRPTをチェックしてtotal-failure-session-countがゼロより大きいかチェックするスクリプト
(対象はGoogleから貰うレポート)
こんな感じでメールがあるディレクトリを指定する
./index.js ~/Maildir/cur/ </description>
    </item>
    
    <item>
      <title>RStudioで正規性の確認</title>
      <link>https://yaasita.github.io/2022/01/26/normal_distribution/</link>
      <pubDate>Wed, 26 Jan 2022 02:50:46 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2022/01/26/normal_distribution/</guid>
      <description>シャピロ-ウィルク(Shapiro-Wilk)の正規性の検定をやる流れ
まず以下のようなデータを用意する
ある音ゲーのスコア
これは音ゲーのスコアを表していてタイミングよく押せた場合はPERFECT, 早すぎたり遅すぎたりした場合はFAST, SLOWに計上される
この内ミスの割合が正規分布と見なせるか検定する
まず、CSVを右上のEnvironmentタブ =&amp;gt; Import Datasetから読み込む
データをMISSの割合をデータフレームに追加
library(dplyr) bandori &amp;lt;- bandori %&amp;gt;% mutate(MISS = (FAST + SLOW) / (PERFECT + FAST + SLOW) * 100) ヒストグラムと近似曲線を出す
hist(bandori$MISS, breaks = seq(0, 20, 1)) dens &amp;lt;- density(bandori$MISS) lines(dens, lwd = 3, col = &amp;#34;blue&amp;#34;) 検定
shapiro.test(bandori$MISS) 検定統計量とp値
data: bandori$MISS W = 0.98162, p-value = 0.724 ここで注意なのはこの検定は帰無仮説が「正規分布している」なので
棄却出来た場合は正規分布ではないと言えるが、
今回のように棄却できない（受容域）の場合は正規分布していてもおかしくない程度なので何とも言えないです
ヒストグラム見る限り正規分布としても良さそうですが
使ったRスクリプト
https://gist.github.com/yaasita/7c431d0493c9703c91d0a013d03349af</description>
    </item>
    
    <item>
      <title>bashでディレクトリのbookmark</title>
      <link>https://yaasita.github.io/2021/09/06/bash-bookmarks/</link>
      <pubDate>Mon, 06 Sep 2021 02:00:02 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2021/09/06/bash-bookmarks/</guid>
      <description>これすごい便利だった
https://threkk.medium.com/how-to-use-bookmarks-in-bash-zsh-6b8074e40774
CDPATHを使うとこんな便利なことができるのね
ただ以下の方が指摘されているようにbashだと補完が効かないので, compgenで補完候補を作る方が良さそう
https://mobile.twitter.com/mattn_jp/status/1434205359573405696
自分の場合は、gotoっていうコマンドよりcdで通常通り使えた方が良いので
こんな感じの設定を追加しておいた
cdコマンドを上書きして、@で始まってたら cd -P でsymlinkを辿るようにして、他は通常通り
(これなら補完候補も足さなくてOK)
export CDPATH=&amp;quot;.:$HOME/.bookmarks&amp;quot; function cd { if [[ ${1} =~ ^@ ]];then cd -P $1 || return 1 return fi builtin cd &amp;quot;$@&amp;quot; || return 1 } あと、bookmarkへの追加もコマンドにしておく
bookmarkしたいディレクトリに移動してbookmarkコマンドでsymlink作るようにしておく
function bookmark { local current_dir=$(pwd) ln -s $current_dir ~/.bookmarks/@$(basename $current_dir) } </description>
    </item>
    
    <item>
      <title>nodejsのreadline</title>
      <link>https://yaasita.github.io/2021/07/29/nodejs-readline/</link>
      <pubDate>Thu, 29 Jul 2021 00:55:40 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2021/07/29/nodejs-readline/</guid>
      <description>readlineの書き方
https://nodejs.org/api/readline.html
こうやって書くより
const rl = readline.createInterface({ // ... }); for await (const line of rl) { // Each line in the readline input will be successively available here as // `line`. } こっちの方がメモリ効率が良さそう
await new Promise((resolv, reject) =&amp;gt; { rl.on(&amp;#34;line&amp;#34;, (line) =&amp;gt; { // 処理 }); rl.on(&amp;#34;close&amp;#34;, () =&amp;gt; { resolv(); }); }); 詳しくは調べてないけど、巨大ファイルだと
FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory `` が頻発する </description>
    </item>
    
    <item>
      <title>AtCoder Beginner Contest 202のD問題</title>
      <link>https://yaasita.github.io/2021/06/06/atcoder-d/</link>
      <pubDate>Sun, 06 Jun 2021 01:49:45 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2021/06/06/atcoder-d/</guid>
      <description>問題
https://atcoder.jp/contests/abc202/tasks
解説
https://www.youtube.com/watch?v=iNSp33TT3tc
ポイントは use bigint; を指定しないと溢れて浮動小数点になってしまう</description>
    </item>
    
    <item>
      <title>tumblrのテキスト情報を取得</title>
      <link>https://yaasita.github.io/2021/05/25/tumblr-metadata/</link>
      <pubDate>Tue, 25 May 2021 00:53:51 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2021/05/25/tumblr-metadata/</guid>
      <description>tumblrの検索だと、上手く引っかからない事が多いので
テキストデータはローカルに保存することにした
最初の投稿から何番目を指定することで、ディレクトリの年別ディレクトリに保存します
実行例
./get-tumblr-text.pl --tumblr_id yaasita --save_dir /tmp/ 1234 こんな感じで適度にsleep入れて取得してます
#!/bin/bash set -eux save_file=/tmp/save_num already_get_number=$(cat $save_file) for ((i=$already_get_number; i &amp;lt; $already_get_number + 100; i++));do ./get-tumblr-text.pl --tumblr_id yaasita --save_dir /tmp/ $i sleep 1 done echo $i &amp;gt; $save_file </description>
    </item>
    
    <item>
      <title>maildir形式のファイルをgmailに移す</title>
      <link>https://yaasita.github.io/2020/08/31/maildir-to-gmail/</link>
      <pubDate>Mon, 31 Aug 2020 03:36:18 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2020/08/31/maildir-to-gmail/</guid>
      <description>IMAPのAPPENDコマンドでmaildir形式のファイルをGmailに送る
#!/usr/bin/env node &amp;quot;use strict&amp;quot;; const simpleParser = require(&amp;quot;mailparser&amp;quot;).simpleParser; const { ImapFlow } = require(&amp;quot;imapflow&amp;quot;); const client = new ImapFlow({ host: &amp;quot;imap.gmail.com&amp;quot;, port: 993, secure: true, auth: { user: &amp;quot;hoge@gmail.com&amp;quot;, pass: &amp;quot;password&amp;quot;, }, }); const fs = require(&amp;quot;fs&amp;quot;); (async () =&amp;gt; { const mail = fs.readFileSync( process.argv[2], &amp;quot;utf8&amp;quot; ); const parsed = await simpleParser(mail); await client.connect(); await client.append(&amp;quot;INBOX&amp;quot;, mail, [&amp;quot;\\Seen&amp;quot;], parsed.date); await client.logout(); })().catch((e) =&amp;gt; { console.log(e); process.exit(1); }); </description>
    </item>
    
    <item>
      <title>authorized_keysを適当に更新しない</title>
      <link>https://yaasita.github.io/2020/07/08/ssh-keys-deploy/</link>
      <pubDate>Wed, 08 Jul 2020 15:14:42 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2020/07/08/ssh-keys-deploy/</guid>
      <description>概要 sshの公開鍵認証で複数人が使うシステムのauthorized_keysを場当たり的に更新してしまうと、誰の鍵が入ってるか分からなくなる
誰の鍵が入ってるか分かるようにした方が良いと思う
スクリプト こんなスクリプトを書いた
使い方はREADME.md参照
https://github.com/yaasita/ssh-keys-manager
その他 使えるならsshの証明書認証も検討した方が良いかも ssh -F でconfig指定できるけど、~/.ssh/configに置いたときと挙動が違うのでスクリプト内にconfig入れる場合は注意 </description>
    </item>
    
    <item>
      <title>express.jsでpostのrawBodyを取得</title>
      <link>https://yaasita.github.io/2020/04/28/rawpostdata/</link>
      <pubDate>Tue, 28 Apr 2020 01:00:16 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2020/04/28/rawpostdata/</guid>
      <description>multipart/form-dataでPOSTされた奴を、処理するCloud functionsを書いてて必要になったので
呼び出し側はこんな感じでやってる</description>
    </item>
    
    <item>
      <title>Github Pagesになってるリポジトリをチェック</title>
      <link>https://yaasita.github.io/2020/01/07/check-github-pages/</link>
      <pubDate>Tue, 07 Jan 2020 18:55:03 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2020/01/07/check-github-pages/</guid>
      <description>どのリポジトリがGithub Pagesの設定がされているか？
調べたくなったので・・・
Github pagesの設定されてるリポジトリ一覧を簡単に確認できればいいのに・・・</description>
    </item>
    
    <item>
      <title>GCP Cloud Functions内からサービスアカウントのtoken取る</title>
      <link>https://yaasita.github.io/2019/12/08/service-account-in-cf/</link>
      <pubDate>Sun, 08 Dec 2019 05:12:12 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2019/12/08/service-account-in-cf/</guid>
      <description>Cloud Functionsからサービスアカウントのアクセストークンをどうやって取るの？と疑問に思ったので調べた
Google Compute Engineと同じ取り方でOK
&amp;quot;use strict&amp;quot;; const fetch = require(&amp;quot;node-fetch&amp;quot;); exports.handler = async (req, res) =&amp;gt; { const url = &amp;quot;http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/&amp;quot; + &amp;quot;[サービスアカウント名]/token&amp;quot;; const result = await fetch(url, { method: &amp;quot;GET&amp;quot;, headers: { &amp;quot;Metadata-Flavor&amp;quot;: &amp;quot;Google&amp;quot; } }); const token = await result.text(); console.log(token); res.status(200).send(&amp;quot;OK&amp;quot;); }; なんでドキュメントにも書いてある今更な事を書くかというと日本語ドキュメントには見出しが無いんですよね。。。。
まだ翻訳終わってないならまだしも（本当は英文のままで良いからタイトルくらいは残してほしいが) &amp;ldquo;Function Identity&amp;quot;とかクリックするとちゃんと日本語版あるんですよね
なんかメニューがバグってるのかな・・・
とりあえず英語版から探すのをオススメします&amp;hellip;
参考リンク
関数ID Compute Metadata Server </description>
    </item>
    
    <item>
      <title>GCPでアクセストークンを取得する</title>
      <link>https://yaasita.github.io/2019/11/14/gcp-access-token/</link>
      <pubDate>Thu, 14 Nov 2019 22:32:41 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2019/11/14/gcp-access-token/</guid>
      <description>ほとんどのサービスは クライアントライブラリ を使えば
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json みたいに環境変数を設定するだけで良いのだが、Cloud Build 等は access tokenを取得して叩く必要がある
という事でGCPのサービスアカウントからアクセストークンを取得するコード
スコープ一覧はこちら
https://developers.google.com/identity/protocols/googlescopes
アクセストークンのテストは DLP とかがお手軽で良いかな
参考リンク jose API Document Using OAuth 2.0 for Server to Server Applications </description>
    </item>
    
  </channel>
</rss>
