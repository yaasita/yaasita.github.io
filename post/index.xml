<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title># cd ~yaasita</title>
    <link>https://yaasita.github.io/post/</link>
    <description>Recent content on # cd ~yaasita</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 20 Jun 2018 23:46:45 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GCPでAWS Batch的な事をやる</title>
      <link>https://yaasita.github.io/2018/06/20/aws-batch-gcp/</link>
      <pubDate>Wed, 20 Jun 2018 23:46:45 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/06/20/aws-batch-gcp/</guid>
      <description> こんな感じにS3になんか置いて、ファイルがあったら起動して、終わったらshutdownするみたいな奴

 function callback(data){ var photos = data.response.posts[0].photos; document.getElementById(&#34;tumblr-img&#34;).parentNode.href = photos[0].original_size.url; document.getElementById(&#34;tumblr-img&#34;).src = photos[0].original_size.url; }   GCPはインスタンスの起動停止が早いので結構良い感じ
Lambda 処理するファイルが存在して、GCPが動いてたら起動かける

GCP キュー代わりのファイル消してから
bootしてから3分後に実行（ちょっとインターバルないとインスタンスに入るのが大変になる）
処理の最後でshutdownすればOK
/etc/systemd/system/gcp-calc.service
[Unit] Description=gcp-calc Wants=network-pre.target After=multi-user.target [Install] WantedBy=multi-user.target [Service] ExecStart=/root/run.sh Type=oneshot  /etc/systemd/system/gcp-calc.timer
[Unit] Description=gcp calc [Timer] OnBootSec=3min [Install] WantedBy=timers.target  </description>
    </item>
    
    <item>
      <title>クライアント証明書とIP制限</title>
      <link>https://yaasita.github.io/2018/05/26/client-auth/</link>
      <pubDate>Sat, 26 May 2018 03:49:43 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/05/26/client-auth/</guid>
      <description>外からはクライアント証明書を要求して、中からは素通しさせたいケース
Apache2.4ならこんな感じ
SSLCACertificateFile /etc/apache2/ssl/example.crt &amp;lt;Directory /var/www&amp;gt; Options Indexes FollowSymLinks MultiViews ExecCGI Require ip 192.168.100.0/24 SSLVerifyClient require Satisfy any &amp;lt;/Directory&amp;gt;  curlで確認
curl https://example.net --key client.key --cert cert.crt --http1.1  作るときは /usr/lib/ssl/misc/CA.pl -newreq とかで適当に作る
鍵とセットなら良いのでcommon nameとかは適当
参考リンク プライベートCA作るまで</description>
    </item>
    
    <item>
      <title>vimのterminalモード</title>
      <link>https://yaasita.github.io/2018/05/19/vim-terminal/</link>
      <pubDate>Sat, 19 May 2018 05:16:04 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/05/19/vim-terminal/</guid>
      <description>メモ
 tmuxパカパカ開くよりは良い気がする
 以下のマッピング追加してペーストできるようにした
if has(&#39;terminal&#39;) tnoremap &amp;lt;C-T&amp;gt; &amp;lt;C-W&amp;gt;&amp;quot;&amp;quot; tnoremap &amp;lt;C-Q&amp;gt; &amp;lt;C-W&amp;gt;N endif  ubuntu18.04でもちょい古くてなんか挙動が少し違うから手動で入れた方が良い
 ビルド
apt-get build-dep vim apt-get install libperl-dev python-dev python3-dev ruby-dev git clone --depth 1 git@github.com:vim/vim.git cd vim make make install   参考リンク
【(Neo)Vim】terminal mode のマッピングについての闇とその解決法
結論：すごく便利だと思います</description>
    </item>
    
    <item>
      <title>たまにはGDBM使う</title>
      <link>https://yaasita.github.io/2018/04/17/gdbm-file/</link>
      <pubDate>Tue, 17 Apr 2018 01:09:31 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/04/17/gdbm-file/</guid>
      <description>2018年にGDBM使う
perl標準モジュールにある
簡単なKVSならこれで
debianだと多分入ってるけど、libperl5.24が無い環境だとダメぽい
#!/usr/bin/perl use strict; use warnings; use feature qw(:5.10); use utf8; use GDBM_File ; my $filename = &amp;quot;gdm&amp;quot;; my %hash; tie %hash, &#39;GDBM_File&#39;, $filename, &amp;amp;GDBM_WRCREAT, 0640; $hash{hoge} = &amp;quot;huga&amp;quot;; say &amp;quot;$_ =&amp;gt; $hash{$_}&amp;quot; for keys %hash;  </description>
    </item>
    
    <item>
      <title>PerlのHTTP::Tiny</title>
      <link>https://yaasita.github.io/2018/04/07/libio-socket-ssl/</link>
      <pubDate>Sat, 07 Apr 2018 04:17:18 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/04/07/libio-socket-ssl/</guid>
      <description>perlのHTTP::Tinyは標準モジュールなんだけど、IO::Socket::SSLが無くて
IO::Socket::SSL 1.42 must be installed for https support  が出ちゃう場合は
apt install libio-socket-ssl-perl  </description>
    </item>
    
    <item>
      <title>GoogleのCloud SDKの署名鍵エラー</title>
      <link>https://yaasita.github.io/2018/04/07/google-cloud-sdk-gpg/</link>
      <pubDate>Sat, 07 Apr 2018 02:24:37 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/04/07/google-cloud-sdk-gpg/</guid>
      <description>GCP(google cloud platform)の署名鍵が変わってた
つーか元のgpg鍵の有効期限が切れてる
取得:1 http://packages.cloud.google.com/apt cloud-sdk-xenial InRelease [6,372 B] エラー:1 http://packages.cloud.google.com/apt cloud-sdk-xenial InRelease 公開鍵を利用できないため、以下の署名は検証できませんでした: NO_PUBKEY 6A030B21BA07F4FB  なんか探してみると2018年4月1日に作った鍵にしてるみたい
gpg2 --search-keys BA07F4FB gpg: data source: http://gpg.NebrWesleyan.edu:11371 (1) Google Cloud Packages Automatic Signing Key &amp;lt;gc-team@google.com&amp;gt; 2048 bit RSA key BA07F4FB, created: 2018-04-01, expires: 2021-03-31  ということで追加して事なきを得た
gpg2 -a --export BA07F4FB | apt-key add - apt-key del A7317B0F  </description>
    </item>
    
    <item>
      <title>Let&#39;s Encryptのワイルドカード</title>
      <link>https://yaasita.github.io/2018/03/31/lets-wildcard/</link>
      <pubDate>Sat, 31 Mar 2018 03:38:25 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/03/31/lets-wildcard/</guid>
      <description>debian testingに
certbot 0.22.2が来てたので使ってみる
とりあえずこんな感じで行った
まだサーバを指定しなきゃいけないけど、これでワイルドカード手に入るのは良い
apt install certbot certbot certonly --manual -d yaasita.net -d *.yaasita.net --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory  </description>
    </item>
    
    <item>
      <title>AlwaysOnSSL</title>
      <link>https://yaasita.github.io/2018/03/21/alwaysonssl/</link>
      <pubDate>Wed, 21 Mar 2018 01:37:01 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/03/21/alwaysonssl/</guid>
      <description>letsencryptとは違う無料のSSLサービス使ってみた
その名も AlwaysOnSSL
サーバ証明書 使って見た感想
 CAAレコード違反のレポートメールは飛んでこなかった
 証明書の期間は1年間
 CTログはComodo CA に書くみたいでLetsencryptより少ない
 ワイルドカードは無理
 SANに複数のドメイン入れるのも無理
  チェインはこんな感じ
DigiCert Global Root G2 |_ AlwaysOnSSL TLS RSA CA G1 |_ yourdomain.example.com  DigiCertなんで大抵のブラウザならOKなはず
curlで簡単に叩けるのでcertbotが入らない場合はこっちの方が良いかも
certbotが入るならLetsencryptの方が良いと思う
S/MIME  有効期間は1年間
 CSR作って署名してもらうので、秘密鍵は自分で作る安心設計
  チェーンはこんな感じ
Symantec Class 1 Public Primary CertificationAuthority - G6 |_ Symantec Class 1 Individual Subscriber CA - G7  普通にメール受信できるなら作ってもらえるとても良い
CNにメールアドレス入れてCSR作ってからVerifyする
そんで、My Certificatesから中間証明書と証明書ダウンロードしてpkcs12にまとめればOK
openssl pkcs12 -export -in merged.</description>
    </item>
    
    <item>
      <title>perlのデストラクタ</title>
      <link>https://yaasita.github.io/2018/03/17/perl-destory/</link>
      <pubDate>Sat, 17 Mar 2018 02:57:05 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/03/17/perl-destory/</guid>
      <description>Ctrl-Cで止めたときもデストラクタを呼びたいときがある
そういう時は、シグナルハンドラを作ればOK
最後に変数のスコープから外れてデストラクタが呼ばれる
 </description>
    </item>
    
    <item>
      <title>Apacheでリバースプロキシ</title>
      <link>https://yaasita.github.io/2018/02/04/apache-header/</link>
      <pubDate>Sun, 04 Feb 2018 16:27:56 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/02/04/apache-header/</guid>
      <description>Apacheでリバースプロキシするときこんな感じに書いた方が良いよという話
&amp;lt;VirtualHost *:443&amp;gt; ServerName example.net &amp;lt;Proxy *&amp;gt; Require all granted &amp;lt;/Proxy&amp;gt; ProxyRequests Off ProxyPreserveHost On ProxyPass / http://192.168.0.1:8080/ keepalive=On ProxyPassReverse / http://192.168.0.1:8080/ RequestHeader set X-Forwarded-Proto &amp;quot;https&amp;quot; RequestHeader unset X-Forwarded-For RequestHeader unset X-Forwarded-Server RequestHeader unset X-Forwarded-Host Include /path/to/common.conf &amp;lt;/VirtualHost&amp;gt;  X-Forwarded-Forとかを一旦unsetしないと、
X-Forwarded-Forとかをクライアント側から指定されると、追加されて判別が困難になる
curl -H &amp;quot;X-Forwarded-For: 1.2.3.4&amp;quot;  みたいな感じで指定されると
 x-forwarded-for: &amp;quot;1.2.3.4, 192.168.0.100&amp;quot;  こんな感じに追加されて http://192.168.0.1:8080 側にわたってしまう</description>
    </item>
    
    <item>
      <title>プライベートCA作るまで</title>
      <link>https://yaasita.github.io/2018/01/31/private-ca/</link>
      <pubDate>Wed, 31 Jan 2018 18:04:22 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/01/31/private-ca/</guid>
      <description>Debian9でやってみた
cd /etc/ssl /usr/lib/ssl/misc/CA.pl -newca /usr/lib/ssl/misc/CA.pl -newreq /usr/lib/ssl/misc/CA.pl -sign # /tmp/ca.pemを入れてもらう openssl x509 -outform PEM -in demoCA/cacert.pem -out /tmp/ca.pem # 変換 openssl x509 -outform PEM -in newcert.pem -out /etc/nginx/ssl/hogehoge.crt # パスフレーズ解除 openssl rsa -in newkey.pem -out /etc/nginx/ssl/hogehoge.key  データベースおかしくなったら
index.txt空っぽすればOK
rm demoCA/index.txt touch demoCA/index.txt  /etc/ssl/openssl.cnf は こんな感じ
証明書の管理は
chromeなら設定 =&amp;gt; 詳細設定 =&amp;gt; SSLの管理からやる
windowsの場合はファイル名を指定して実行 =&amp;gt; certlm.msc と同じこと
あと注意点として、chromeはsubjectAltNameを見るので注意
(EnableCommonNameFallbackForLocalAnchorsってやつを設定するとできるようだけど)</description>
    </item>
    
    <item>
      <title>GoogleHomeでPCつける</title>
      <link>https://yaasita.github.io/2018/01/14/google-home/</link>
      <pubDate>Sun, 14 Jan 2018 03:41:21 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2018/01/14/google-home/</guid>
      <description>Mojoliciousで受けてコマンド叩くだけ
IFTTTはこんな感じにして


Mojolicious側のコントローラはこんな感じで受けた

喋りたくない時もあるので、JavaScriptでも叩けるようにした(適当な場所にHTML置いておいた)
function hogeop(){ postjson({key: &#39;huga&#39;}) } function postjson(j) { fetch(&amp;quot;/google&amp;quot;, { method: &amp;quot;POST&amp;quot;, headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }, body: JSON.stringify(j) }).then(res =&amp;gt; res.json()).then(res =&amp;gt; { console.log(res) }); }  結論: こうやって家電を操作できるのは楽しい
 function callback(data){ var photos = data.response.posts[0].photos; document.getElementById(&#34;tumblr-img1&#34;).parentNode.href = photos[0].original_size.url; document.getElementById(&#34;tumblr-img1&#34;).src = photos[0].original_size.url; document.getElementById(&#34;tumblr-img2&#34;).parentNode.href = photos[1].original_size.url; document.getElementById(&#34;tumblr-img2&#34;).src = photos[1].original_size.url; }   </description>
    </item>
    
    <item>
      <title>systemd-nspawnアドベントカレンダー</title>
      <link>https://yaasita.github.io/2017/12/19/systemd-nspawn-adcal/</link>
      <pubDate>Tue, 19 Dec 2017 04:34:55 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/12/19/systemd-nspawn-adcal/</guid>
      <description>書きました
https://qiita.com/advent-calendar/2017/systemd-nspawn</description>
    </item>
    
    <item>
      <title>gpgでサブキーを指定して暗号化</title>
      <link>https://yaasita.github.io/2017/12/04/gpg-specify-subkey/</link>
      <pubDate>Mon, 04 Dec 2017 23:27:01 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/12/04/gpg-specify-subkey/</guid>
      <description>gpgで副鍵(subkey)を新しく作ったとする(addkey)
でいざ使うと思ったら、やむ負えない事情により古い副鍵で暗号化しなきゃいけなくなったとする
こんな感じの状態ね
pub rsa2048 2017-04-09 [SC] XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX uid [ultimate] yamasita &amp;lt;yamasita@example.net&amp;gt; sub rsa2048 2017-04-09 [E] sub elg2048 2017-12-04 [E]  んで、普通にgpg -e で暗号化すると新しい elg2048 の方が使われてしまう
rsa2048を使いたくなったらこんな感じでrsa2048の方のIDを指定して暗号化する
gpg --recipient BBBBBBBBBBB12345! -v -e memo  IDは&amp;ndash;edit-keysとかやれば見れるお
あと、注意点として副鍵は追加しても古い鍵はしばらく残しておくこと
送信側がすぐ、新しい鍵を入れてくれるとも限らないし古い鍵で暗号化されたものを復号化できなくなる
主鍵は、副鍵を署名するだけのものであって、副鍵の秘密鍵は取っておかなきゃいけないのです</description>
    </item>
    
    <item>
      <title>MonaCoinのマイニング</title>
      <link>https://yaasita.github.io/2017/12/03/mona-coin/</link>
      <pubDate>Sun, 03 Dec 2017 01:30:08 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/12/03/mona-coin/</guid>
      <description>モナコインをマイニングしてみる
cpuminer-multiでやってみた
スコア  IDCF Cloud (Light.S1) メモリ1GB 仮想1CPU =&amp;gt; 17.48 kH/s
 自宅PC Core i5-4460 @ 3.20GHz 4コア メモリ 4GB =&amp;gt; 376 kH/s
 ノートパソコン LB-C110B Celeron 1037U 2コア/1.80GHz メモリ8GB =&amp;gt; 91 kH/s
  まとめ CPUマイニングなんてやるもんじゃない←結論</description>
    </item>
    
    <item>
      <title>TeratermからConEmuへ移行した</title>
      <link>https://yaasita.github.io/2017/12/02/teraterm-to-conemu/</link>
      <pubDate>Sat, 02 Dec 2017 04:36:08 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/12/02/teraterm-to-conemu/</guid>
      <description>長年使ってたTeratermからConEmuへ移行した
SSHクライアントはputtyを使ってる
WSL経由でも良かったんだけど、なんかVimのvisualモードで背景色が変わらなかったり表示が微妙だったので結局putty使った
良かった点  絵文字も表示できる
 タブが便利(TeratermもCollectorで出来るけどこっちの方が使いやすい)
 F1キーをリモート側に送るとかそういう設定がしやすい
  微妙な点  Alt-Vでペーストしてたけどこれが使えない(設定方法が分からない)
  まとめ ConEmu入れた後putty設定したり、微妙に面倒だけど使いやすい</description>
    </item>
    
    <item>
      <title>PS Vita 3.67アップデートでTLS1.2対応</title>
      <link>https://yaasita.github.io/2017/11/29/vita-new-version/</link>
      <pubDate>Wed, 29 Nov 2017 23:20:37 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/11/29/vita-new-version/</guid>
      <description>3.65時点だと対応してなかったけど、3.67でTLS1.2対応したようです🎉
公式には
 システムソフトウェアにおいて、動作の安定性を改善しました。
 としか書いてないけど</description>
    </item>
    
    <item>
      <title>SSL証明書の有効期限チェック</title>
      <link>https://yaasita.github.io/2017/11/24/ssl-check/</link>
      <pubDate>Fri, 24 Nov 2017 01:54:56 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/11/24/ssl-check/</guid>
      <description>なんか必要だったので、シェルとかでも良いけど
 </description>
    </item>
    
    <item>
      <title>Teratermでreject clipbordのエラー</title>
      <link>https://yaasita.github.io/2017/11/16/teraterm-copy/</link>
      <pubDate>Thu, 16 Nov 2017 06:33:07 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/11/16/teraterm-copy/</guid>
      <description> teraterm + Tmuxでコピーをすると
Reject clipboard write access from remoteのエラーが出る
これはOSC52っていう制御文字を使ってリモートからOSのクリップボードを書き込むことができる機能がブロックされてるよって事
直すには Setup -&amp;gt; Addtional settings -&amp;gt; Control Sequenceタブ
と進んで該当箇所を設定すればOK
その下にNotifyの設定もある

参考リンク  リモートの tmux でコピーした内容のローカルのクリップボードへの反映
   function callback(data){ var photos = data.response.posts[0].photos; document.getElementById(&#34;tumblr-img&#34;).parentNode.href = photos[0].original_size.url; document.getElementById(&#34;tumblr-img&#34;).src = photos[0].original_size.url; }   </description>
    </item>
    
    <item>
      <title>s3fsとIPアドレス制限だけのpublic bucket</title>
      <link>https://yaasita.github.io/2017/11/07/s3fs-public-bucket/</link>
      <pubDate>Tue, 07 Nov 2017 01:36:51 +0900</pubDate>
      
      <guid>https://yaasita.github.io/2017/11/07/s3fs-public-bucket/</guid>
      <description>s3fsを使ってこんな感じのバケットポリシーのs3をマウントするときのやつ
(hogehogeバケットとその中身を特定IPアドレスの人に開放する)
{ &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;, &amp;quot;Id&amp;quot;: &amp;quot;Policy1509977001523&amp;quot;, &amp;quot;Statement&amp;quot;: [ { &amp;quot;Sid&amp;quot;: &amp;quot;Stmt1509976998204&amp;quot;, &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;, &amp;quot;Principal&amp;quot;: &amp;quot;*&amp;quot;, &amp;quot;Action&amp;quot;: &amp;quot;s3:*&amp;quot;, &amp;quot;Resource&amp;quot;: &amp;quot;arn:aws:s3:::hogehoge&amp;quot;, &amp;quot;Condition&amp;quot;: { &amp;quot;IpAddress&amp;quot;: { &amp;quot;aws:SourceIp&amp;quot;: &amp;quot;203.0.113.1&amp;quot; } } }, { &amp;quot;Sid&amp;quot;: &amp;quot;Stmt1509976998204&amp;quot;, &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;, &amp;quot;Principal&amp;quot;: &amp;quot;*&amp;quot;, &amp;quot;Action&amp;quot;: &amp;quot;s3:*&amp;quot;, &amp;quot;Resource&amp;quot;: &amp;quot;arn:aws:s3:::hogehoge/*&amp;quot;, &amp;quot;Condition&amp;quot;: { &amp;quot;IpAddress&amp;quot;: { &amp;quot;aws:SourceIp&amp;quot;: &amp;quot;203.0.113.1&amp;quot; } } } ] }  んでs3fsはこんな感じ
s3fs -o public_bucket=1,rw,allow_other,umask=0022,endpoint=ap-northeast-1,default_acl=public-read hogehoge /mnt  public_bucketがポイント</description>
    </item>
    
  </channel>
</rss>
